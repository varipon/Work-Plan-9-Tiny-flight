# ================
# SOFTWARE LICENSE
# ================

# The MIT License (MIT)

# Copyright (c) 2019 Yutaka Sawai (Varipon)

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# ==============================================================
# LICENSE FOR CONTENT PROCEDURALLY GENERATED USING THIS SOFTWARE
# ==============================================================

# All content procedurally generated by this software and its permutations
# are licensed under Creative Commons Attribution By 3.0:

# https://creativecommons.org/licenses/by/3.0/


#!/usr/bin/python

import bpy
from bpy import *

import mathutils
import math
from mathutils import *
from math import *


class Formula:

    J = 18 #joint number
    
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)


    def configMovement(self, P, A, J, a, b, y, o):

        mat_a = [0 for i in range(4)] # Joint α matrix
        mat_b = [0 for i in range(self.J)] # Joint β matrix
        mat_y = [0 for i in range(self.J)] # Joint γ matrix
        mat_o = [0 for i in range(self.J)] # Joint δ matrix

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        a[0] = mathutils.Euler((-A - E + (D * 0.5), -A - (D * 0.5), 0), 'XYZ')
        print ("a0 =", a[0])
        mat_a[0] = Matrix.Translation(a[0])

        a[3] = mathutils.Euler((0-a[0].x, 0-a[0].y, 0-a[0].z), 'XYZ')
        print ("a3 =", a[3])
        mat_a[3] = Matrix.Translation(a[3]) 

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])
        mat_y[1] = Matrix.Translation(y[1])

### pattern A

        b[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y + (A * 2), 0), 'XYZ')
        print ("b2 =", b[2])
        mat_b[2] = Matrix.Translation(b[2])

        b[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (A * 2), 0), 'XYZ')
        print ("b3 =", b[3])
        mat_b[3] = Matrix.Translation(b[3])
        
        y[2] = mathutils.Euler((a[0].x + E, a[0].y, 0), 'XYZ')
        print ("y2 =", y[2])
        mat_y[2] = Matrix.Translation(y[2])

        y[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (D * 0.5), 0), 'XYZ')
        print ("y3 =", y[3])
        mat_y[3] = Matrix.Translation(y[3])

        o[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y - (A * 2), 0), 'XYZ')
        print ("o2 =", o[2])
        mat_o[2] = Matrix.Translation(o[2])
        
        o[3] = mathutils.Euler((a[0].x + E - (D * 0.5) - (A * 2), a[0].y - (D * 0.5) - (A * 2), 0), 'XYZ')
        print ("o3 =", o[3])
        mat_o[3] = Matrix.Translation(o[3])

### pattern A end

        org_rot_mat = Matrix.Rotation(math.radians(0), 4, 'Z')

        # define the rotation
        rot_mat = Matrix.Rotation(math.radians(-45), 4, 'Z')   

        for j in range(2, J - 2):

            mat_y[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_y[j]

#            obj.matrix_world = mat_y[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_y[j + 2].decompose()
            y[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("y"+str(j + 2)+" = ", y[j + 2], rot, sca)

            mat_b[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_b[j]
            
#            obj.matrix_world = mat_b[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_b[j + 2].decompose()
            b[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("b"+str(j + 2)+" = ", b[j + 2], rot, sca)

            mat_o[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_o[j]
            
#            obj.matrix_world = mat_o[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_o[j + 2].decompose()
            o[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("o"+str(j + 2)+" = ", o[j + 2], rot, sca)


    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 1):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-2):
                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]


        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 1):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')
        

    def configRotation(self, rig, interval, frame_start, frame_end, start, end):

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        # key insert 
        keyframe_insert_interval = interval

        rig.pose.bones["a1b1"].rotation_mode = 'XYZ'
        rig.pose.bones["a1b1"].rotation_euler.z = math.radians(start) 
        rig.pose.bones["a1b1"].keyframe_insert(data_path="rotation_euler",frame=frame_start)

        rig.pose.bones["a1b1"].rotation_mode = 'XYZ'
        rig.pose.bones["a1b1"].rotation_euler.z = math.radians(end)
        rig.pose.bones["a1b1"].keyframe_insert(data_path="rotation_euler",frame=frame_end)

        for curve in bpy.context.active_object.animation_data.action.fcurves:
            cycles = curve.modifiers.new(type='CYCLES')
            cycles.mode_before = 'REPEAT_OFFSET'
            cycles.mode_after = 'REPEAT_OFFSET'

            for keyframe in curve.keyframe_points:
                keyframe.interpolation = 'LINEAR'

        bpy.ops.object.mode_set(mode='OBJECT')


    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)


        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True
    
        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


    def constructLink(self, A, J, helicity, rig, move, part):

        # Move and rotate the tip bone in pose mode
        bpy.context.scene.objects.active = rig 

        Y = 1.1838*A

        for n in rig.pose.bones:
    
            if n.name != "o" + str(J-2) + "b" + str(J-1):
                # we can get the object from the pose bone
                obj = n.id_data
                matrix_final = obj.matrix_world * n.matrix

                # Create armature and object
                lnk = bpy.data.armatures.new(n.name[:len(n.name)]+'.data.' + helicity)
                lnk_rig = bpy.data.objects.new(n.name[:len(n.name)]+'.link.' + helicity, lnk)
                lnk_rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')

                # rig.show_x_ray = True
                lnk.show_names = True
                lnk.draw_type = 'STICK'

                # Link object to scene
                scn = bpy.context.scene
                scn.objects.link(lnk_rig)
                scn.objects.active = lnk_rig
                scn.update()

                # Create bones

                # mode='EDIT'
                bpy.ops.object.editmode_toggle()
    
                link = lnk.edit_bones.new(n.name[:len(n.name)])
                link.head = (0, 0, 0)
                link.tail = (0, Y, 0)

                link_head = lnk.edit_bones.new('head')
                link_head.head = (0, 0, 0.1)
                link_head.tail = (0, 0, 0)
                link_head.parent = link
                link_head.use_inherit_scale = False

                link_tail = lnk.edit_bones.new('tail')
                link_tail.head = (0, Y, 0)
                link_tail.tail = (0, Y, -0.1)
                link_tail.parent = link
                link_tail.use_inherit_scale = False

                bpy.ops.object.mode_set(mode='OBJECT')

                ob = bpy.data.objects[n.name[:len(n.name)]+'.mesh.' + move + '.' + part +'.' + helicity]
                ob.location = mathutils.Euler((0, 0, 0), 'XYZ')
    
                # Give mesh object an armature modifier, using vertex groups but
                # not envelopes
                mod = ob.modifiers.new('MyRigModif', 'ARMATURE')
                mod.object = lnk_rig
                mod.use_bone_envelopes = False
                mod.use_vertex_groups = True

                # Bone constraints. Armature must be in pose mode.
                bpy.ops.object.mode_set(mode='POSE')
 
                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_LOCATION')
                cns.name = 'Copy_Location'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_ROTATION')
                cns.name = 'Copy_Rotation'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # StretchTo constraint Mid -> Tip with influence 0.5
                cns1 = pBase.constraints.new('STRETCH_TO')
                cns1.name = 'Stretch'
                cns1.target = rig
                cns1.subtarget = n.name[:len(n.name)]
                cns1.head_tail = 1
                cns1.rest_length = Y
                cns1.influence = 1
                cns1.keep_axis = 'PLANE_Z'
                cns1.volume = 'NO_VOLUME'

                bpy.ops.object.mode_set(mode='OBJECT')


class Wing(Formula):
    
    J = 6 #joint number
    
    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ
        self.w = [0 for i in range(self.J+1)] # Joint ω

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.helicity, self.part, self.a, self.b, self.y, self.o, self.w)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o, self.w)
 
        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)


    # Overriding Configuration Movement
    def configMovement(self, P, A, J, helicity, part, a, b, y, o, w):

        mat_a = [0 for i in range(4)] # Joint α matrix
        mat_b = [0 for i in range(self.J)] # Joint β matrix
        mat_y = [0 for i in range(self.J)] # Joint γ matrix
        mat_o = [0 for i in range(self.J)] # Joint δ matrix

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        a[0] = mathutils.Euler((-A - E + (D * 0.5), -A - (D * 0.5), 0), 'XYZ')
        print ("a0 =", a[0])
        mat_a[0] = Matrix.Translation(a[0])

        a[3] = mathutils.Euler((0-a[0].x, 0-a[0].y, 0-a[0].z), 'XYZ')
        print ("a3 =", a[3])
        mat_a[3] = Matrix.Translation(a[3]) 

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])
        mat_y[1] = Matrix.Translation(y[1])

### pattern A

        b[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y + (A * 2), 0), 'XYZ')
        print ("b2 =", b[2])
        mat_b[2] = Matrix.Translation(b[2])

        b[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (A * 2), 0), 'XYZ')
        print ("b3 =", b[3])
        mat_b[3] = Matrix.Translation(b[3])
        
        y[2] = mathutils.Euler((a[0].x + E, a[0].y, 0), 'XYZ')
        print ("y2 =", y[2])
        mat_y[2] = Matrix.Translation(y[2])

        y[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (D * 0.5), 0), 'XYZ')
        print ("y3 =", y[3])
        mat_y[3] = Matrix.Translation(y[3])

        o[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y - (A * 2), 0), 'XYZ')
        print ("o2 =", o[2])
        mat_o[2] = Matrix.Translation(o[2])
        
        o[3] = mathutils.Euler((a[0].x + E - (D * 0.5) - (A * 2), a[0].y - (D * 0.5) - (A * 2), 0), 'XYZ')
        print ("o3 =", o[3])
        mat_o[3] = Matrix.Translation(o[3])

### pattern A end

        org_rot_mat = Matrix.Rotation(math.radians(0), 4, 'Z')

        # define the rotation
        rot_mat = Matrix.Rotation(math.radians(-45), 4, 'Z')   

        for j in range(2, J - 2):

            mat_y[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_y[j]

#            obj.matrix_world = mat_y[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_y[j + 2].decompose()
            y[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("y"+str(j + 2)+" = ", y[j + 2], rot, sca)

            mat_b[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_b[j]
            
#            obj.matrix_world = mat_b[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_b[j + 2].decompose()
            b[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("b"+str(j + 2)+" = ", b[j + 2], rot, sca)

            mat_o[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_o[j]
            
#            obj.matrix_world = mat_o[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_o[j + 2].decompose()
            o[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("o"+str(j + 2)+" = ", o[j + 2], rot, sca)

        if helicity == 'right':
            H = 1
        else:
            H = -1
            
        w[0] = mathutils.Euler((-A , y[4].y, -B * H), 'XYZ')
        print ("w0 =", w[0])
      
        w[1] = mathutils.Euler((-A , y[4].y, -B*2 * H), 'XYZ')
        print ("w1 =", w[1])

        if (part == 'hindwing-right') or (part == 'hindwing-left'):
            xx = -1.50085
            yy = -2.25039
        else:
            xx = -0.449372
            yy = -3.19989

        w[2] = mathutils.Euler((xx, yy, 0.227393 * H), 'XYZ')
        w[3] = mathutils.Euler((xx, yy, -0.445137 * H), 'XYZ')
        print ("w2 =", w[2])
        print ("w3 =", w[3])

        w[4] = mathutils.Euler((xx, yy, -0.938895 * H), 'XYZ')
        print ("w4 =", w[4])
        w[5] = mathutils.Euler((xx, yy, -13.06 * H), 'XYZ')
        print ("w5 =", w[5])
        w[6] = mathutils.Euler((xx, yy, -28.8051 * H), 'XYZ')
        print ("w6 =", w[6])

    

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o, w):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 1):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            if j < (J - 2):
                yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
                yy[j][j+1].head = y[j]
                yy[j][j+1].tail = y[j+1]
                yy[j][j+1].parent = by[j][j]

                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]


        # y4 2 fulcrum vector
        y4_fulcrum = amt.edit_bones.new('y4_fulcrum')
        y4_fulcrum.head = y[4]
        y4_fulcrum.tail = w[0]
        y4_fulcrum.parent = yy[3][4]

        y4_fulcrum_tail = amt.edit_bones.new('y4_fulcrum.tail')
        y4_fulcrum_tail.head = w[0]
        y4_fulcrum_tail.tail = w[1]
        y4_fulcrum_tail.parent = y4_fulcrum

        # formula y3y4 ginbal_ring x-axis
        g_y3y4_x = amt.edit_bones.new('g_y3y4.x')
        g_y3y4_x.head = y[3]
        g_y3y4_x.tail = y[4]
        g_y3y4_x.parent = by[3][3]
        
        # formula y3y4 ginbal_ring z-axis
        g_y3y4_z = amt.edit_bones.new('g_y3y4.z')
        g_y3y4_z.head = y[4]
        g_y3y4_z.tail = w[0]
        g_y3y4_z.parent = g_y3y4_x

        # formula b4y4 ginbal_ring x-axis
        g_b4y4_x = amt.edit_bones.new('g_b4y4.x')
        g_b4y4_x.head = b[4]
        g_b4y4_x.tail = y[4]
        g_b4y4_x.parent = ob[3][4]

        # formula b4y4 ginbal_ring z-axis
        g_b4y4_z = amt.edit_bones.new('g_b4y4.z')
        g_b4y4_z.head = y[4]
        g_b4y4_z.tail = w[0]
        g_b4y4_z.parent = g_b4y4_x


        # fulcrum 2 y4
        fulcrum_y4 = amt.edit_bones.new('fulcrum_y4')
        fulcrum_y4.head = w[4]
        fulcrum_y4.tail = w[3]
        fulcrum_y4.parent = aa[2][1]

        # fulcrum y4 tail
        fulcrum_y4_tail = amt.edit_bones.new('fulcrum_y4.tail')
        fulcrum_y4_tail.head = w[3]
        fulcrum_y4_tail.tail = w[2]
        fulcrum_y4_tail.parent = fulcrum_y4
    

        # fulcrum gimbal 1 y-axis
        g_1_y = amt.edit_bones.new('g_1.y')
        g_1_y.head = mathutils.Euler((w[4].x, y[4].y + 1.0720, w[4].z), 'XYZ')
        g_1_y.tail = w[4]
        g_1_y.parent = aa[2][1]

        # fulcrum gimbal 2 x-axis
        g_2_x = amt.edit_bones.new('g_2.x')
        g_2_x.head = w[4]
        g_2_x.tail = w[3]
        g_2_x.parent = g_1_y
    
    
        # wings gimbal 3 z-axis
        g_3_z = amt.edit_bones.new('g_3.z')
        g_3_z.head = w[4]
        g_3_z.tail = w[5]
        g_3_z.parent = g_2_x

#        # wings gimbal 4 z-axis
        g_4_z = amt.edit_bones.new('g_4.z')
        g_4_z.head = w[5]
        g_4_z.tail = w[6]
        g_4_z.parent = g_2_x


        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 1):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        # IK constraint y4 -> fulcrum
        cns = rig.pose.bones['y4_fulcrum'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = rig
        cns.subtarget = 'fulcrum_y4'
        cns.head_tail = 0

        # IK constraint fulcrum -> y4
        cns = rig.pose.bones['fulcrum_y4'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = rig
        cns.subtarget = 'y3y4'
        cns.head_tail = 1

        # IK constraint g_1.z - g_2.x - y4
        cns = rig.pose.bones['g_2.x'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'fulcrum_y4.tail'
        cns.pole_target = rig
        cns.pole_subtarget = 'fulcrum_y4'
        cns.chain_count = 2
        cns.use_stretch = False
        cns.pole_angle = math.radians(-90)

        # Copy rotation constraints
        cns = rig.pose.bones['g_3.z'].constraints.new('COPY_ROTATION')
        cns.name = 'Copy_Rotation'
        cns.target = rig
        cns.subtarget = 'g_y3y4.z'
        cns.owner_space = 'WORLD'
        cns.target_space = 'WORLD'

        # Copy rotation constraints
        cns = rig.pose.bones['g_4.z'].constraints.new('COPY_ROTATION')
        cns.name = 'Copy_Rotation'
        cns.target = rig
        cns.subtarget = 'g_b4y4.z'
        cns.owner_space = 'WORLD'
        cns.target_space = 'WORLD'

        # IK constraint
        cns = rig.pose.bones['g_y3y4.z'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y4_fulcrum.tail'
        cns.pole_target = rig
        cns.pole_subtarget = 'y4_fulcrum'
        cns.chain_count = 2
        cns.use_stretch = False
        cns.pole_angle = math.radians(90)

        # IK constraint
        cns = rig.pose.bones['g_b4y4.z'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y4_fulcrum.tail'
        cns.pole_target = rig
        cns.pole_subtarget = 'y4_fulcrum'
        cns.chain_count = 2
        cns.use_stretch = False
        if helicity == 'right':
            cns.pole_angle = math.radians(90)
        else:
            cns.pole_angle = math.radians(90)

        bpy.ops.object.mode_set(mode='OBJECT')

        
    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
        
        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4_fulcrum.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4_fulcrum.tail.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "fulcrum_y4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "fulcrum_y4.tail.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        if part == 'hindwing-left' or part == 'hindwing-right':
            if helicity == 'left':
                obj_joint = bpy.data.objects["joint.gold.wing.a2a1.hind.L"].copy()
            else:
                obj_joint = bpy.data.objects["joint.gold.wing.a2a1.hind.R"].copy()
        else:
            if helicity == 'left':
                obj_joint = bpy.data.objects["joint.gold.wing.a2a1.fore.L"].copy()
            else:
                obj_joint = bpy.data.objects["joint.gold.wing.a2a1.fore.R"].copy()
            

        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for n in range(1, J - 2):

            if n <= (J-3):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

            if n <= (J-4):

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4o4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
                
        obj_joint = bpy.data.objects["joint.green.b4y4.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b4y4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        if helicity == 'right':
            obj_joint = bpy.data.objects["joint.gold.y3y4.R"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.y3y4.L"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        if helicity == 'right':
            obj_joint = bpy.data.objects["joint.gold.g_y3y4.x.R"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.g_y3y4.x.L"].copy()            
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_y3y4.x.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.g_y3y4.z.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_y3y4.z.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.green.g_b4y4.z.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_b4y4.z.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.green.g_b4y4.x.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_b4y4.x.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.green.g_1.y.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_1.y.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.blue.g_2.x.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_2.x.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.silver.g_3.z.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_3.z.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.g_4.z.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_4.z.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True
    
        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


    def constructLink(self, A, J, helicity, rig, move, part):

        # Move and rotate the tip bone in pose mode
        bpy.context.scene.objects.active = rig 

        Y = 1.1838*A

        for n in rig.pose.bones:

            # we can get the object from the pose bone
            obj = n.id_data
            matrix_final = obj.matrix_world * n.matrix

            # Create armature and object
            lnk = bpy.data.armatures.new(n.name[:len(n.name)]+'.data.' + helicity)
            lnk_rig = bpy.data.objects.new(n.name[:len(n.name)]+'.link.' + helicity, lnk)
            lnk_rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')

            # rig.show_x_ray = True
            lnk.show_names = True
            lnk.draw_type = 'STICK'

            # Link object to scene
            scn = bpy.context.scene
            scn.objects.link(lnk_rig)
            scn.objects.active = lnk_rig
            scn.update()

            # Create bones

            # mode='EDIT'
            bpy.ops.object.editmode_toggle()
    
            link = lnk.edit_bones.new(n.name[:len(n.name)])
            link.head = (0, 0, 0)
            link.tail = (0, Y, 0)

            link_head = lnk.edit_bones.new('head')
            link_head.head = (0, 0, 0.1)
            link_head.tail = (0, 0, 0)
            link_head.parent = link
            link_head.use_inherit_scale = False

            link_tail = lnk.edit_bones.new('tail')
            link_tail.head = (0, Y, 0)
            link_tail.tail = (0, Y, -0.1)
            link_tail.parent = link
            link_tail.use_inherit_scale = False

            bpy.ops.object.mode_set(mode='OBJECT')

            ob = bpy.data.objects[n.name[:len(n.name)]+'.mesh.' + move + '.' + part +'.' + helicity]
            ob.location = mathutils.Euler((0, 0, 0), 'XYZ')
    
            # Give mesh object an armature modifier, using vertex groups but
            # not envelopes
            mod = ob.modifiers.new('MyRigModif', 'ARMATURE')
            mod.object = lnk_rig
            mod.use_bone_envelopes = False
            mod.use_vertex_groups = True

            # Bone constraints. Armature must be in pose mode.
            bpy.ops.object.mode_set(mode='POSE')
 
            # Copy rotation constraints Base -> Tip
            pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
            cns = pBase.constraints.new('COPY_LOCATION')
            cns.name = 'Copy_Location'
            cns.target = rig
            cns.subtarget = n.name[:len(n.name)]
            cns.owner_space = 'WORLD'
            cns.target_space = 'WORLD'

            # Copy rotation constraints Base -> Tip
            pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
            cns = pBase.constraints.new('COPY_ROTATION')
            cns.name = 'Copy_Rotation'
            cns.target = rig
            cns.subtarget = n.name[:len(n.name)]
            cns.owner_space = 'WORLD'
            cns.target_space = 'WORLD'

            # StretchTo constraint Mid -> Tip with influence 0.5
            cns1 = pBase.constraints.new('STRETCH_TO')
            cns1.name = 'Stretch'
            cns1.target = rig
            cns1.subtarget = n.name[:len(n.name)]
            cns1.head_tail = 1
            cns1.rest_length = Y
            cns1.influence = 1
            cns1.keep_axis = 'PLANE_Z'
            cns1.volume = 'NO_VOLUME'

            bpy.ops.object.mode_set(mode='OBJECT')


class Body(Formula):

    J = 8 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
            hindwingleft_loc, hindwingleft_rot, hindwingleft,
            hindwingright_loc, hindwingright_rot, hindwingright,
            forewingleft_loc, forewingleft_rot, forewingleft,
            forewingright_loc, forewingright_rot, forewingright):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        self.hindwingleft_loc = hindwingleft_loc
        self.hindwingleft_rot = hindwingleft_rot
        self.hindwingleft = hindwingleft

        self.hindwingright_loc = hindwingright_loc
        self.hindwingright_rot = hindwingright_rot
        self.hindwingright = hindwingright

        self.forewingleft_loc = forewingleft_loc
        self.forewingleft_rot = forewingleft_rot
        self.forewingleft = forewingleft

        self.forewingright_loc = forewingright_loc
        self.forewingright_rot = forewingright_rot
        self.forewingright = forewingright

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)
        
        # Parent set wing to upperbody        
        self.setParent(self.helicity, self.move, self.rig,
                self.hindwingleft_loc, self.hindwingleft_rot, self.hindwingleft,
                self.hindwingright_loc, self.hindwingright_rot, self.hindwingright,
                self.forewingleft_loc, self.forewingleft_rot, self.forewingleft,
                self.forewingright_loc, self.forewingright_rot, self.forewingright)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.5, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.5, self.J, self.helicity, self.rig, self.move, self.part)


    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler((6.84652, -5.67915, 0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler((8.26062, -13.0787, 0), 'XYZ')
        print ("b3 =", b[3])
        
        b[4] = mathutils.Euler((18.1585, -15.6664, 0), 'XYZ')
        print ("b4 =", b[4])

        b[5] = mathutils.Euler((18.0728, -21.7068, 0), 'XYZ')
        print ("b5 =", b[5])

        b[6] = mathutils.Euler((27.5848, -29.9893, 0), 'XYZ')
        print ("b6 =", b[6])

        
        o[2] = mathutils.Euler((8.26062, -4.26505, 0), 'XYZ')
        print ("o2 =", o[2])

        o[3] = mathutils.Euler((11.9114, -15.6664, 0), 'XYZ')
        print ("o3 =", o[3])

        o[4] = mathutils.Euler((18.0729, -15.752, 0), 'XYZ')
        print ("o4 =", o[4])

        o[5] = mathutils.Euler((20.5394, -22.9449, 0), 'XYZ')
        print ("o5 =", o[5])

        o[6] = mathutils.Euler((29.323, -28.0525, 0), 'XYZ')
        print ("o6 =", o[6])
        

        y[2] = mathutils.Euler((5.67915, -6.84652, 0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler((11.9114, -13.0787, 0), 'XYZ')
        print ("y3 =", y[3])
        
        y[4] = mathutils.Euler((16.3287, -17.4961, 0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler((20.5394, -21.7068, 0), 'XYZ')
        print ("y5 =", y[5])

        y[6] = mathutils.Euler((27.5848, -28.7522, 0), 'XYZ')
        print ("y6 =", y[6])

        y[7] = mathutils.Euler((31.936, -33.1033, 0), 'XYZ')
        print ("y7 =", y[7])


    # Parent set wing to upper body        
    def setParent(self, helicity, move, rig, 
            hindwingleft_loc, hindwingleft_rot, hindwingleft,
            hindwingright_loc, hindwingright_rot, hindwingright,
            forewingleft_loc, forewingleft_rot, forewingleft,
            forewingright_loc, forewingright_rot, forewingright):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select = True
        bpy.context.scene.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b1y1' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')


        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        hindwingleft.rig.select = True
        hindwingright.rig.select = True

        forewingleft.rig.select = True
        forewingright.rig.select = True

        rig.select = True
        bpy.context.scene.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects


        # left hind wing position
        hindwingleft.rig.location.x += hindwingleft_loc[0]
        hindwingleft.rig.location.y += hindwingleft_loc[1]
        hindwingleft.rig.location.z += hindwingleft_loc[2]

        hindwingleft.rig.rotation_euler = hindwingleft_rot

        # right hind wing position
        hindwingright.rig.location.x += hindwingright_loc[0]
        hindwingright.rig.location.y += hindwingright_loc[1]
        hindwingright.rig.location.z += hindwingright_loc[2]

        hindwingright.rig.rotation_euler = hindwingright_rot


        # left front wing position
        forewingleft.rig.location.x += forewingleft_loc[0]
        forewingleft.rig.location.y += forewingleft_loc[1]
        forewingleft.rig.location.z += forewingleft_loc[2]

        forewingleft.rig.rotation_euler = forewingleft_rot

        # right front wing position
        forewingright.rig.location.x += forewingright_loc[0]
        forewingright.rig.location.y += forewingright_loc[1]
        forewingright.rig.location.z += forewingright_loc[2]

        forewingright.rig.rotation_euler = forewingright_rot


        loc = (0, -26.9518, -4.43703)
        rot = mathutils.Euler((math.radians(-90), math.radians(77.5692), math.radians(-270)), 'XYZ')

        # lower body position
        rig.location.x += loc[0]
        rig.location.y += loc[1]
        rig.location.z += loc[2]

        rig.rotation_euler = rot
        

def formula():

# pivot factor
    P = 0

# scale factor
    A = 1
    
# name
    move = 'formula'

# element
    part = 'universe'

# left or right
    helicity = 'left'

    start = 0
    end = start+360

    formula = Formula(P, A, move, part, helicity, start, end)


def hindwingright():

# scale factor
    A = 0.379*0.461597

# pivot factor
    P = 0
    
# name
    move = 'damselfly-thrust'

# element
    part = 'hindwing-right'

# left or right
    helicity = 'right'

    start = 154.909
    end = start+360
    
    global hindwingright
    hindwingright = Wing(P, A, move, part, helicity, start, end)


def hindwingleft():

# scale factor
    A = 0.379*0.461597

# pivot factor
    P = 0
    
# name
    move = 'damselfly-thrust'

# element
    part = 'hindwing-left'

# left or right
    helicity = 'left'

    start = 205.09
    end = start-360

    global hindwingleft
    hindwingleft = Wing(P, A, move, part, helicity, start, end)


def forewingright():

# scale factor
    A = 0.379*0.461597

# pivot factor
    P = 0
    
# name
    move = 'damselfly-thrust'

# element
    part = 'forewing-right'

# left or right
    helicity = 'right'

    start = 30.0998
    end = start+360
    
    global forewingright
    forewingright = Wing(P, A, move, part, helicity, start, end)


def forewingleft():

# scale factor
    A = 0.379*0.461597

# pivot factor
    P = 0
    
# name
    move = 'damselfly-thrust'

# element
    part = 'forewing-left'

# left or right
    helicity = 'left'

    start = -30.1082
    end = start-360

    global forewingleft
    forewingleft = Wing(P, A, move, part, helicity, start, end)


def body():

# scale factor
    A = 0.583684

# pivot factor
    P = 0

# name
    move = 'damselfly-thrust'

# helicity
    helicity = 'left'

# limbs element
    part = 'body'

    start = 123.83 # 
    end = 123.83 # 


    hindwingleft_loc = (6.28539, -5.58136, -0.940303)
    hindwingleft_rot = mathutils.Euler((math.radians(0), math.radians(180), math.radians(-78.3731)), 'XYZ')

    global hindwingleft

    hindwingright_loc = (6.28539, -5.58136, 0.940303)
    hindwingright_rot = mathutils.Euler((math.radians(0), math.radians(180), math.radians(-78.3731)), 'XYZ')

    global hindwingright


    forewingleft_loc = (5.35632, -6.52987, -0.390262)
    forewingleft_rot = mathutils.Euler((math.radians(0), math.radians(180), math.radians(-78.3731)), 'XYZ')

    global forewingleft

    forewingright_loc = (5.35632, -6.52987, 0.390262)
    forewingright_rot = mathutils.Euler((math.radians(0), math.radians(180), math.radians(-78.3731)), 'XYZ')

    global forewingright


    global body
    body = Body(P, A, move, part, helicity, start, end,
        hindwingleft_loc, hindwingleft_rot, hindwingleft,
        hindwingright_loc, hindwingright_rot, hindwingright,
        forewingleft_loc, forewingleft_rot, forewingleft,
        forewingright_loc, forewingright_rot, forewingright)


def main(origin):

    global interval
    global frame_start
    global frame_end

    frame_start = 214.0

    frame_end = 381.0
    
    interval = frame_end - frame_start

#    formula()
    hindwingright()
    hindwingleft()
    forewingright()
    forewingleft()
    body()
   
if __name__ == "__main__":
    # renaming of corrada objects
#    for ob in context.scene.objects:
#        if "joint_" in ob.name:
#            ob.name = ob.name.replace("_", ".")
            
    main((0,0,0))
